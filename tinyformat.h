// tinyformat.h
// Copyright (C) 2011, Christopher J. Foster
//
// Boost Software License - Version 1.0
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

// Tinyformat: A minimal type safe printf-replacement library for C++
//
// This library aims to support 95% of casual C++ string formatting needs with
// a single lightweight header file.
//
// Example usage:
// --------------
//
// std::string name = "Neddy Seagoon";
// float age = 31.41;
// tfm::printf("My name is %s and I am %.2f years old", name, age);
//
//
// Function reference:
// -------------------
// TODO
// void format(std::ostream& stream, const char* formatString,
//             const T1& value1, const T2& value1, ...)
//
// std::string format(const char* formatString,
//                      const T1& value1, const T2& value1, ...)
//
// void printf(const char* formatString,
//             const T1& value1, const T2& value1, ...)
//
//
// Error handling:
// ---------------
// TODO
//
//
// Formatting user-defined types:
// ------------------------------
// TODO
//
//
// Rationale:
// ----------
//
// There are lots of other excellent and complete solutions to the formatting
// problem (boost::format and fastformat come to mind, but there are many
// others).  Unfortunately, these tend to be very heavy dependencies for
// the purposes of the average "casual" formatting.
//
// This heavyness manifests in two ways:
// (1) Large build time dependencies, with many files
// (2) Slow build times (this is particularly noticable with boost::format)
//
// This library is also a reaction to the frustrating verbosity of
// stream-based formatting and as such opts for the classic printf-style
// design.
//
// Design goals:
// * Simplicity and minimalism.  A single header file to include.
// * Some extensibility for user-defined types.
// * Parse standard C99 format strings
// * Support as many commonly used printf() features as practical using
//   the std::ostream features.

#ifndef TINYFORMAT_H_INCLUDED
#define TINYFORMAT_H_INCLUDED

#include <cassert>
#include <iostream>
#include <sstream>

namespace tinyformat {}
//------------------------------------------------------------------------------
// Config section.  Customize to your liking!
namespace tfm = tinyformat;

#define TINYFORMAT_ASSERT(x) assert(x)


//------------------------------------------------------------------------------

#ifndef TINYFORMAT_USE_VARADIC_TEMPLATES
#   ifdef __GXX_EXPERIMENTAL_CXX0X__
#       define TINYFORMAT_USE_VARADIC_TEMPLATES
#   endif
#endif

namespace tinyformat {

#ifdef TINYFORMAT_SHOULDNT_BE_DEFINED
// The following three functions conceptually form the tinyformat interface

// Format the arguments to the supplied stream.
//
// This function is the main part of the tinyformat interface.
//
// out is the output stream, fmt is a format string in C99 printf() format,
// and args stands for a list of types T1, T2, ... TN, taken by const
// reference.
template<typename... Args>
inline void format(std::ostream& out, const char* fmt, const Args&... args);


// Convenience function: format the arguments into a std::string
//
// This convenience function simply calls the main version of format() using a
// std::stringstream, and returns the resulting string.
template<typename... Args>
inline std::string format(const char* fmt, const Args&... args);


// Convenience function: calls format() with std::cout as the first argument.
template<typename... Args>
inline void printf(const char* fmt, const Args&... args);
#endif


// Format a value into a stream. Called from format() for all types by default.
//
// Users may override this for their own types.  When this function is called,
// the stream flags will have been modified according to the format string.
//
// By default, formatValue() uses the usual stream insertion operator
// operator<< to format the type T.
template<typename T>
inline void formatValue(std::ostream& out, const char* fmtBegin,
                        const char* fmtEnd, const T& value);


// Format a value into a stream, called for all types by format()
//
// Users should override this function for their own types if they intend to 
template<typename T>
inline void formatValueBasic(std::ostream& out, const char* fmtBegin,
                             const char* fmtEnd, const T& value);


//------------------------------------------------------------------------------
// Implementation details.
namespace detail {

// Parse and return an integer from the string c, as atoi()
// On return, c is set to one past the end of the integer.
inline int parseIntAndAdvance(const char*& c)
{
    int i = 0;
    for(;*c >= '0' && *c <= '9'; ++c)
        i = 10*i + (*c - '0');
    return i;
}


// Parse the format string and set the stream state accordingly.
//
// The format mini-language recognized here is meant to be the one from C99,
// with the form
//
// "%[flags][width][.precision][length]type".
inline void streamStateFromFormat(std::ostream& out, const char* fmtStart,
                                  const char* fmtEnd)
{
    const char* c = fmtStart;
    // 1) Parse flags
    for(;; ++c)
    {
        switch(*c)
        {
            case '#': out.setf(std::ios::showpoint | std::ios::showbase); continue;
            case '0': out.fill('0');                                      continue;
            case '-': out.setf(std::ios::left, std::ios::adjustfield);    continue;
            case ' ': out.fill(' ');                                      continue;
            case '+': out.setf(std::ios::showpos);                        continue;
        }
        break;
    }
    // 2) Parse width 
    if(*c >= '0' && *c <= '9')
        out.width(parseIntAndAdvance(c));
    // Ignore variable-specified width for simplicity.
    if(*c == '*')
        ++c;
    // 3) Parse precision
    if(*c == '.')
    {
        ++c;
        if(*c >= '0' && *c <= '9')
            out.precision(parseIntAndAdvance(c));
    }
    // 4) Ignore any C99 length modifier
    while(*c == 'l' || *c == 'h' || *c == 'L' ||
          *c == 'j' || *c == 'z' || *c == 't')
        ++c;
    // 5) We're up to the conversion specifier character.
    char type = 's';
    if(c < fmtEnd)
        type = *c;
    // Set stream flags based on conversion specifier.  boost::format was very
    // helpful in compiling the list of correspondences here.
    switch(type)
    {
        case 'u': case 'd': case 'i':
            out.setf(std::ios::dec, std::ios::basefield);
            break;
        case 'o':
            out.setf(std::ios::oct, std::ios::basefield);
            break;
        case 'X':
            out.setf(std::ios::uppercase);
        case 'x': case 'p':
            out.setf(std::ios::hex, std::ios::basefield);
            break;
        case 'E':
            out.setf(std::ios::uppercase);
        case 'e':
            out.setf(std::ios::scientific, std::ios::floatfield);
            out.setf(std::ios::dec, std::ios::basefield);
            break;
        case 'F':
            out.setf(std::ios::uppercase);
        case 'f':
            out.setf(std::ios::fixed, std::ios::floatfield);
            break;
        case 'G':
            out.setf(std::ios::uppercase);
        case 'g':
            out.setf(std::ios::dec, std::ios::basefield);
            // As in boost::format, let stream decide float format.
            out.flags(out.flags() & ~std::ios::floatfield);
            break;
        case 'a': case 'A':
            break; // C99 hexadecimal floating point??  punt!
        case 'c':
            // Handled elsewhere by overriding formatValue()
            break;
        case 's':
            // TODO - if precision is set, should truncate width.
            break;
    }
    // we shouldn't be past the end, though we may equal it if the input
    // format was broken and ended with '\0'.
    assert(c <= fmtEnd);
}


inline bool nextFormatFragment(const char* fmt, const char** formatBegin,
                               const char** formatEnd)
{
    // Skip through literal part of the string.
    const char* c = fmt;
    while(*c != '\0' && *c != '%')
        ++c;
    *formatBegin = c;
    *formatEnd = c;
    if(*c == '\0')
        return false;
    // Now we have *c == '%', the start of the format specifier.
    ++c;
    if(*c == '%')
    {
        // TODO: Proper % handling.
        *formatEnd = c+1;
        return true;
    }
    // Advance to end of format specifier.
    for(;*c != '\0'; ++c)
    {
        // For compatibility with C, argument length modifiers don't terminate
        // the format
        if(*c == 'l' || *c == 'h' || *c == 'L' ||
           *c == 'j' || *c == 'z' || *c == 't')
            continue;
        // ... but any other upper or lower case letter does
        if((*c >= 'A' && *c <= 'Z') || (*c >= 'a' && *c <= 'z'))
            break;
    }
    if(*c != '\0')
        ++c;
    *formatEnd = c;
    if(*c == '\0')
        return false;
    return true;
}

} // namespace detail


template<typename T>
inline void formatValue(std::ostream& out, const char* fmtBegin,
                        const char* fmtEnd, const T& value)
{
    // Use operator<< by default; may be overridden by user.
    out << value;
}


inline void formatValue(std::ostream& out, const char* fmtBegin,
                        const char* fmtEnd, int value)
{
    // Overridden to support '%c' conversion.
    if(*(fmtEnd-1) == 'c')
        out << (char)value;
    else
        out << value;
}


template<typename T>
inline void formatValueBasic(std::ostream& out, const char* fmtBegin,
                             const char* fmtEnd, const T& value)
{
    // Save stream state
    std::streamsize width = out.width();
    std::streamsize precision = out.precision();
    std::ios::fmtflags flags = out.flags();
    char fill = out.fill();
    // Set state & format the value
    detail::streamStateFromFormat(out, fmtBegin, fmtEnd);
    formatValue(out, fmtBegin, fmtEnd, value);
    // Restore stream state
    out.width(width);
    out.precision(precision);
    out.flags(flags);
    out.fill(fill);
}


// Format function,  0-argument case.
inline bool format(std::ostream& out, const char* fmt)
{
    const char* c = fmt;
    while(*c != '\0' && *c != '%')
        ++c;
    out << fmt;
    return *c != '%';
}


#ifdef TINYFORMAT_USE_VARADIC_TEMPLATES

// N-argument case: formats one element and calls N-1 argument case.
template<typename T1, typename... Args>
inline bool format(std::ostream& out, const char* fmt, const T1& value1,
                   const Args&... args)
{
    const char* literalEnd = 0;
    const char* formatSpecEnd = 0;
    detail::nextFormatFragment(fmt, &literalEnd, &formatSpecEnd);
    out.write(fmt, literalEnd - fmt);
    formatValueBasic(out, literalEnd+1, formatSpecEnd, value1);
    format(out, formatSpecEnd, args...);
    return true; // TODO
}


// Create a std::string rather than formatting to a stream.
template<typename... Args>
inline std::string format(const char* fmt, const Args&... args)
{
    std::ostringstream oss;
    format(oss, fmt, args...);
    return oss.str();
}


// Format to stdout, just like printf.
template<typename... Args>
inline void printf(const char* fmt, const Args&... args)
{
    format(std::cout, fmt, args...);
}

#else

// For C++98 we don't have varadic templates so we need to generate code
// outside the language.  We could do this with some ugly macros but instead
// let's use a short snippet of python code with the help of the cog code
// generation framework:

/*[[[cog

template = \
'''
template<%s>
inline bool format(std::ostream& out, const char* fmt, %s)
{
    const char* literalEnd = 0;
    const char* formatSpecEnd = 0;
    detail::nextFormatFragment(fmt, &literalEnd, &formatSpecEnd);
    out.write(fmt, literalEnd - fmt);
    FormatSpec spec(literalEnd+1, formatSpecEnd);
    formatValue(out, spec, value1);
    format(%s);
    return true; // TODO
}
'''

maxParams = 4

for i in range(1,maxParams+1):
    paramRange = range(1,i+1)
    typeList = ', '.join(['typename T%d' % (j,) for j in paramRange])
    paramList = ', '.join(['const T%d& value%d' % (j,j) for j in paramRange])
    nextFormatParams = ', '.join(['out', 'formatSpecEnd'] +
                                 ['value%d' % (j,) for j in paramRange[1:]])
    cog.outl(template % (typeList, paramList, nextFormatParams))
]]]*/
//[[[end]]]
#endif

} // namespace tinyformat

#endif // TINYFORMAT_H_INCLUDED
