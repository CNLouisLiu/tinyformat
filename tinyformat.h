// tinyformat.h
// Copyright (C) 2011, Chris Foster [chris42f (at) gmail (d0t) com]
//
// Boost Software License - Version 1.0
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//------------------------------------------------------------------------------
// Tinyformat: A minimal type safe printf-replacement library for C++
//
// This library aims to support 95% of casual C++ string formatting needs with
// a single lightweight header file.  Anything you can do with this library
// can also be done with the standard C++ streams, but probably with
// considerably more typing :)
//
//
// Example usage
// -------------
//
// To print the date, we might have
//
// std::string weekday = "Wednesday";
// const char* month = "July";
// long day = 27;
// int hour = 14;
// int min = 44;
//
// tfm::format(std::cout, "%s, %s %d, %.2d:%.2d\n",
//             weekday, month, day, hour, min);
//
// (The types here are intentionally odd to emphasize the type safety of the
// interface.)  The same thing could be achieved using either of the two
// convenience functions.  One returns a std::string:
//
// std::string date = tfm::format("%s, %s %d, %.2d:%.2d\n",
//                                weekday, month, day, hour, min);
// std::cout << date;
//
// The other prints to the std::cout stream:
//
// tfm::printf("%s, %s %d, %.2d:%.2d\n", weekday, month, day, hour, min);
//
//
// Function reference
// ------------------
//
// Three interface functions are available: an iostreams-based format(), a
// string-based format() and printf().
//
//
// The format() function taking a stream as the first argument is the main
// part of the tinyformat interface.  stream is the output stream, fmt is a
// format string in C99 printf() format, and the values to be formatted are a
// list of types T1, T2, ... TN, taken by const reference.
//
// void format(std::ostream& stream, const char* formatString,
//             const T1& value1, const T2& value1, ...)
//
//
// The second format() is a convenience function which returns a
// std::string rather than This convenience function simply calls the main
// version of format() using a std::stringstream, and returns the resulting
// string.
//
// std::string format(const char* formatString,
//                    const T1& value1, const T2& value1, ...)
//
//
// printf() is a convenience function which calls format() with std::cout
// as the first argument.
//
// void printf(const char* formatString,
//             const T1& value1, const T2& value1, ...)
//
//
// Error Handling
// --------------
//
// By default, tinyformat calls assert() if it encounters an error in the
// format string or number of arguments.  This behaviour can be changed by
// defining the TINYFORMAT_ERROR macro before including tinyformat.h, or
// editing the config section below.
//
//
// Formatting user defined types
// -----------------------------
//
// User defined types with a stream insertion operator<< will be formatted
// using that operator by default.  For further customization, the user can
// override the formatValue() and formatValueBasic() functions; see the
// implementation for a detailed description.
//
//
// Rationale
// ---------
// Or - why reinvent the wheel?
//
// It's true that there are lots of other excellent and complete solutions to
// the formatting problem (boost::format and fastformat come to mind, but
// there are many others).  Unfortunately, these tend to be very heavy
// dependencies for the purposes of the average "casual" formatting usage.
// This heaviness manifests in two ways:
//
// 1. Large build time dependencies with many source files.  This means the
//    alternatives aren't suitable to bundle within other projects.
// 2. Slow build times for every file using the formatting headers (this is
//    very noticeable with boost/format.hpp. I'm not sure about the various
//    other alternatives.)
//
// tinyformat tries to solve these problems while providing formatting which
// is sufficiently general for "most purposes".
//
// Design goals:
// * Simplicity and minimalism.  A single header file to include.
// * Extensibility for user-defined types.
// * Parse standard C99 format strings
// * Support as many commonly used printf() features as practical without
//   compromising on simplicity.
//

#ifndef TINYFORMAT_H_INCLUDED
#define TINYFORMAT_H_INCLUDED

#include <cassert>
#include <iostream>
#include <sstream>

namespace tinyformat {}
//------------------------------------------------------------------------------
// Config section.  Customize to your liking!

// Namespace alias to encourage brevity
namespace tfm = tinyformat;

// Error handling; calls assert() by default.
// #define TINYFORMAT_ERROR(reasonString) your_error_handler(reasonString)

// Use C++0x varadic templates to make the code shorter & more general
// #define TINYFORMAT_USE_VARADIC_TEMPLATES


//------------------------------------------------------------------------------
// Implementation details.
#ifndef TINYFORMAT_ERROR
#   define TINYFORMAT_ERROR(reason) assert(0 && reason)
#endif

#if !defined(TINYFORMAT_USE_VARADIC_TEMPLATES) && !defined(TINYFORMAT_NO_VARADIC_TEMPLATES)
#   ifdef __GXX_EXPERIMENTAL_CXX0X__
#       define TINYFORMAT_USE_VARADIC_TEMPLATES
#   endif
#endif

namespace tinyformat {

//------------------------------------------------------------------------------
namespace detail {

// Parse and return an integer from the string c, as atoi()
// On return, c is set to one past the end of the integer.
inline int parseIntAndAdvance(const char*& c)
{
    int i = 0;
    for(;*c >= '0' && *c <= '9'; ++c)
        i = 10*i + (*c - '0');
    return i;
}


// Parse the format string and set the stream state accordingly.
//
// The format mini-language recognized here is meant to be the one from C99,
// with the form "%[flags][width][.precision][length]type".
//
// Some format specs (notably ones of the form "%.Ns" for some decimal number
// N) request that the output be truncated to the given precision.  Truncation
// is signalled by returning the truncation length.  If no truncation is to be
// performed, -1 is returned.
inline int streamStateFromFormat(std::ostream& out, const char* fmtStart,
                                 const char* fmtEnd)
{
    int truncateLength = -1;
    bool precisionSet = false;
    const char* c = fmtStart;
    // 1) Parse flags
    bool leftJustify = false;
    for(;; ++c)
    {
        switch(*c)
        {
            case '#':
                out.setf(std::ios::showpoint | std::ios::showbase);
                continue;
            case '0':
                if(!leftJustify)
                    out.fill('0');
                continue;
            case '-':
                leftJustify = true;
                out.fill(' ');
                out.setf(std::ios::left, std::ios::adjustfield);
                continue;
            case ' ':
                out.fill(' ');
                continue;
            case '+':
                out.setf(std::ios::showpos);
                continue;
        }
        break;
    }
    // 2) Parse width 
    if(*c >= '0' && *c <= '9')
        out.width(parseIntAndAdvance(c));
    if(*c == '*')
        TINYFORMAT_ERROR("tinyformat: variable field widths not supported");
    // 3) Parse precision
    if(*c == '.')
    {
        ++c;
        if(*c == '*')
            TINYFORMAT_ERROR("tinyformat: variable field widths not supported");
        int precision = 0;
        if(*c >= '0' && *c <= '9')
            precision = parseIntAndAdvance(c);
        else if(*c == '-') // negative precisions ignored, treated as zero.
            parseIntAndAdvance(++c);
        out.precision(precision);
        precisionSet = true;
    }
    // 4) Ignore any C99 length modifier
    while(*c == 'l' || *c == 'h' || *c == 'L' ||
          *c == 'j' || *c == 'z' || *c == 't')
        ++c;
    // 5) We're up to the conversion specifier character.
    char type = 's';
    if(c < fmtEnd)
        type = *c;
    // Set stream flags based on conversion specifier (thanks to the
    // boost::format class for forging the way here).
    switch(type)
    {
        case 'u': case 'd': case 'i':
            out.setf(std::ios::dec, std::ios::basefield);
            break;
        case 'o':
            out.setf(std::ios::oct, std::ios::basefield);
            break;
        case 'X':
            out.setf(std::ios::uppercase);
        case 'x': case 'p':
            out.setf(std::ios::hex, std::ios::basefield);
            break;
        case 'E':
            out.setf(std::ios::uppercase);
        case 'e':
            out.setf(std::ios::scientific, std::ios::floatfield);
            out.setf(std::ios::dec, std::ios::basefield);
            break;
        case 'F':
            out.setf(std::ios::uppercase);
        case 'f':
            out.setf(std::ios::fixed, std::ios::floatfield);
            break;
        case 'G':
            out.setf(std::ios::uppercase);
        case 'g':
            out.setf(std::ios::dec, std::ios::basefield);
            // As in boost::format, let stream decide float format.
            out.flags(out.flags() & ~std::ios::floatfield);
            break;
        case 'a': case 'A':
            break; // C99 hexadecimal floating point??  punt!
        case 'c':
            // Handled elsewhere by overriding formatValue()
            break;
        case 's':
            if(precisionSet)
                truncateLength = out.precision();
            break;
        case 'n':
            // Not supported - will cause problems!
            TINYFORMAT_ERROR("tinyformat: %n conversion spec not supported");
            break;
    }
    // we shouldn't be past the end, though we may equal it if the input
    // format was broken and ended with '\0'.
    assert(c <= fmtEnd);
    return truncateLength;
}


// Print literal part of format string and return next format spec position.
//
// Skips over any occurrences of '%%', printing a literal '%' to the output.
// The position of the first non-'%' character of the next format spec is
// returned, or the end of string.
inline const char* printFormatStringLiteral(std::ostream& out, const char* fmt)
{
    const char* c = fmt;
    for(; *c != '\0'; ++c)
    {
        if(*c == '%')
        {
            out.write(fmt, c - fmt);
            fmt = ++c;
            if(*c != '%')
                return c;
            // for '%%' the required '%' will be tacked onto the next section.
        }
    }
    out.write(fmt, c - fmt);
    return c;
}


// Skip to end of format spec & return it.  fmt is expected to point to the
// character after the '%' in the spec.
inline const char* findFormatSpecEnd(const char* fmt)
{
    // Advance to end of format specifier.
    const char* c = fmt;
    if(*c == '\0')
        TINYFORMAT_ERROR("tinyformat: Not enough conversion specifiers in format string");
    for(; *c != '\0'; ++c)
    {
        // For compatibility with C, argument length modifiers don't terminate
        // the format
        if(*c == 'l' || *c == 'h' || *c == 'L' ||
           *c == 'j' || *c == 'z' || *c == 't')
            continue;
        // ... but for generality any other upper or lower case letter does
        if((*c >= 'A' && *c <= 'Z') || (*c >= 'a' && *c <= 'z'))
            return c+1;
    }
    TINYFORMAT_ERROR("tinyformat: Conversion spec incorrectly terminated by end of string");
    return c;
}

} // namespace detail


// Variable formatting functions.  May be overridden for user-defined types if
// desired.


// Format a value into a stream. Called from format() for all types by default.
//
// Users may override this for their own types.  When this function is called,
// the stream flags will have been modified according to the format string.
// The format specification is provided in the range [fmtBegin, fmtEnd).
//
// By default, formatValue() uses the usual stream insertion operator
// operator<< to format the type T.
template<typename T>
inline void formatValue(std::ostream& out, const char* fmtBegin,
                        const char* fmtEnd, const T& value)
{
    out << value;
}


// Overridden to support '%c' conversion.
inline void formatValue(std::ostream& out, const char* fmtBegin,
                        const char* fmtEnd, int value)
{
    if(*(fmtEnd-1) == 'c')
        out << (char)value;
    else
        out << value;
}


// Format a value into a stream, called for all types by format()
//
// Users should override this function for their own types if they intend to
// completely customize the formatting, and don't want tinyformat to attempt
// to set the stream flags based on the format specifier string.
//
// The format specification is provided in the range [fmtBegin, fmtEnd).
template<typename T>
inline void formatValueBasic(std::ostream& out, const char* fmtBegin,
                             const char* fmtEnd, const T& value)
{
    // Save stream state
    std::streamsize width = out.width();
    std::streamsize precision = out.precision();
    std::ios::fmtflags flags = out.flags();
    char fill = out.fill();
    // Set stream state.
    int truncateLength = detail::streamStateFromFormat(out, fmtBegin, fmtEnd);
    // Format the value into the stream.
    if(truncateLength < 0)
        formatValue(out, fmtBegin, fmtEnd, value);
    else
    {
        // Special case: the format spec told us to truncate the formatted
        // result.  For generality, do this with a temporary stream.
        std::ostringstream oss;
        oss.copyfmt(out);
        oss << value;
        std::string result = oss.str();
        if((int)result.size() > truncateLength)
            out.write(result.c_str(), truncateLength);
        else
            out << result;
    }
    // Restore stream state
    out.width(width);
    out.precision(precision);
    out.flags(flags);
    out.fill(fill);
}


// Format function, 0-argument case.
inline void format(std::ostream& out, const char* fmt)
{
    fmt = detail::printFormatStringLiteral(out, fmt);
    if(*fmt != '\0')
        TINYFORMAT_ERROR("tinyformat: Too many conversion specifiers in format string");
}


#ifdef TINYFORMAT_USE_VARADIC_TEMPLATES

// N-argument case; formats one element and calls N-1 argument case.
template<typename T1, typename... Args>
inline void format(std::ostream& out, const char* fmt, const T1& value1,
                   const Args&... args)
{
    fmt = detail::printFormatStringLiteral(out, fmt);
    const char* fmtEnd = detail::findFormatSpecEnd(fmt);
    formatValueBasic(out, fmt, fmtEnd, value1);
    format(out, fmtEnd, args...);
}

// Implement convenience functions in terms of format(stream, fmt, ...)
template<typename... Args>
inline std::string format(const char* fmt, const Args&... args)
{
    std::ostringstream oss;
    format(oss, fmt, args...);
    return oss.str();
}

template<typename... Args>
inline void printf(const char* fmt, const Args&... args)
{
    format(std::cout, fmt, args...);
}

#else

// For C++98 we don't have varadic templates so we need to generate code
// outside the language.  We could do this with some ugly macros but instead
// let's use a short snippet of python code with the help of the excellent cog
// code generation script ( http://nedbatchelder.com/code/cog/ )

/*[[[cog

template = \
'''
// %(i)s argument versions
template<%(typenameList)s>
inline void format(std::ostream& out, const char* fmt, %(paramList)s)
{
    fmt = detail::printFormatStringLiteral(out, fmt);
    const char* fmtEnd = detail::findFormatSpecEnd(fmt);
    formatValueBasic(out, fmt, fmtEnd, v1);
    format(%(nextArgList)s);
}
template<%(typenameList)s>
inline std::string format(const char* fmt, %(paramList)s)
{
    std::ostringstream oss;
    format(oss, fmt, %(argList)s);
    return oss.str();
}
template<%(typenameList)s>
inline void printf(const char* fmt, %(paramList)s)
{
    format(std::cout, fmt, %(argList)s);
}'''

maxParams = 10

for i in range(1,maxParams+1):
    paramRange = range(1,i+1)
    typenameList = ', '.join(['typename T%d' % (j,) for j in paramRange])
    paramList = ', '.join(['const T%d& v%d' % (j,j) for j in paramRange])
    argList = ', '.join(['v%d' % (j,) for j in paramRange])
    nextArgList = ', '.join(['out', 'fmtEnd'] +
                            ['v%d' % (j,) for j in paramRange[1:]])
    cog.outl(template % locals())
]]]*/

// 1 argument versions
template<typename T1>
inline void format(std::ostream& out, const char* fmt, const T1& v1)
{
    fmt = detail::printFormatStringLiteral(out, fmt);
    const char* fmtEnd = detail::findFormatSpecEnd(fmt);
    formatValueBasic(out, fmt, fmtEnd, v1);
    format(out, fmtEnd);
}
template<typename T1>
inline std::string format(const char* fmt, const T1& v1)
{
    std::ostringstream oss;
    format(oss, fmt, v1);
    return oss.str();
}
template<typename T1>
inline void printf(const char* fmt, const T1& v1)
{
    format(std::cout, fmt, v1);
}

// 2 argument versions
template<typename T1, typename T2>
inline void format(std::ostream& out, const char* fmt, const T1& v1, const T2& v2)
{
    fmt = detail::printFormatStringLiteral(out, fmt);
    const char* fmtEnd = detail::findFormatSpecEnd(fmt);
    formatValueBasic(out, fmt, fmtEnd, v1);
    format(out, fmtEnd, v2);
}
template<typename T1, typename T2>
inline std::string format(const char* fmt, const T1& v1, const T2& v2)
{
    std::ostringstream oss;
    format(oss, fmt, v1, v2);
    return oss.str();
}
template<typename T1, typename T2>
inline void printf(const char* fmt, const T1& v1, const T2& v2)
{
    format(std::cout, fmt, v1, v2);
}

// 3 argument versions
template<typename T1, typename T2, typename T3>
inline void format(std::ostream& out, const char* fmt, const T1& v1, const T2& v2, const T3& v3)
{
    fmt = detail::printFormatStringLiteral(out, fmt);
    const char* fmtEnd = detail::findFormatSpecEnd(fmt);
    formatValueBasic(out, fmt, fmtEnd, v1);
    format(out, fmtEnd, v2, v3);
}
template<typename T1, typename T2, typename T3>
inline std::string format(const char* fmt, const T1& v1, const T2& v2, const T3& v3)
{
    std::ostringstream oss;
    format(oss, fmt, v1, v2, v3);
    return oss.str();
}
template<typename T1, typename T2, typename T3>
inline void printf(const char* fmt, const T1& v1, const T2& v2, const T3& v3)
{
    format(std::cout, fmt, v1, v2, v3);
}

// 4 argument versions
template<typename T1, typename T2, typename T3, typename T4>
inline void format(std::ostream& out, const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4)
{
    fmt = detail::printFormatStringLiteral(out, fmt);
    const char* fmtEnd = detail::findFormatSpecEnd(fmt);
    formatValueBasic(out, fmt, fmtEnd, v1);
    format(out, fmtEnd, v2, v3, v4);
}
template<typename T1, typename T2, typename T3, typename T4>
inline std::string format(const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4)
{
    std::ostringstream oss;
    format(oss, fmt, v1, v2, v3, v4);
    return oss.str();
}
template<typename T1, typename T2, typename T3, typename T4>
inline void printf(const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4)
{
    format(std::cout, fmt, v1, v2, v3, v4);
}

// 5 argument versions
template<typename T1, typename T2, typename T3, typename T4, typename T5>
inline void format(std::ostream& out, const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5)
{
    fmt = detail::printFormatStringLiteral(out, fmt);
    const char* fmtEnd = detail::findFormatSpecEnd(fmt);
    formatValueBasic(out, fmt, fmtEnd, v1);
    format(out, fmtEnd, v2, v3, v4, v5);
}
template<typename T1, typename T2, typename T3, typename T4, typename T5>
inline std::string format(const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5)
{
    std::ostringstream oss;
    format(oss, fmt, v1, v2, v3, v4, v5);
    return oss.str();
}
template<typename T1, typename T2, typename T3, typename T4, typename T5>
inline void printf(const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5)
{
    format(std::cout, fmt, v1, v2, v3, v4, v5);
}

// 6 argument versions
template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
inline void format(std::ostream& out, const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6)
{
    fmt = detail::printFormatStringLiteral(out, fmt);
    const char* fmtEnd = detail::findFormatSpecEnd(fmt);
    formatValueBasic(out, fmt, fmtEnd, v1);
    format(out, fmtEnd, v2, v3, v4, v5, v6);
}
template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
inline std::string format(const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6)
{
    std::ostringstream oss;
    format(oss, fmt, v1, v2, v3, v4, v5, v6);
    return oss.str();
}
template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
inline void printf(const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6)
{
    format(std::cout, fmt, v1, v2, v3, v4, v5, v6);
}

// 7 argument versions
template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
inline void format(std::ostream& out, const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7)
{
    fmt = detail::printFormatStringLiteral(out, fmt);
    const char* fmtEnd = detail::findFormatSpecEnd(fmt);
    formatValueBasic(out, fmt, fmtEnd, v1);
    format(out, fmtEnd, v2, v3, v4, v5, v6, v7);
}
template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
inline std::string format(const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7)
{
    std::ostringstream oss;
    format(oss, fmt, v1, v2, v3, v4, v5, v6, v7);
    return oss.str();
}
template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
inline void printf(const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7)
{
    format(std::cout, fmt, v1, v2, v3, v4, v5, v6, v7);
}

// 8 argument versions
template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
inline void format(std::ostream& out, const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8)
{
    fmt = detail::printFormatStringLiteral(out, fmt);
    const char* fmtEnd = detail::findFormatSpecEnd(fmt);
    formatValueBasic(out, fmt, fmtEnd, v1);
    format(out, fmtEnd, v2, v3, v4, v5, v6, v7, v8);
}
template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
inline std::string format(const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8)
{
    std::ostringstream oss;
    format(oss, fmt, v1, v2, v3, v4, v5, v6, v7, v8);
    return oss.str();
}
template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
inline void printf(const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8)
{
    format(std::cout, fmt, v1, v2, v3, v4, v5, v6, v7, v8);
}

// 9 argument versions
template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
inline void format(std::ostream& out, const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9)
{
    fmt = detail::printFormatStringLiteral(out, fmt);
    const char* fmtEnd = detail::findFormatSpecEnd(fmt);
    formatValueBasic(out, fmt, fmtEnd, v1);
    format(out, fmtEnd, v2, v3, v4, v5, v6, v7, v8, v9);
}
template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
inline std::string format(const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9)
{
    std::ostringstream oss;
    format(oss, fmt, v1, v2, v3, v4, v5, v6, v7, v8, v9);
    return oss.str();
}
template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
inline void printf(const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9)
{
    format(std::cout, fmt, v1, v2, v3, v4, v5, v6, v7, v8, v9);
}

// 10 argument versions
template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
inline void format(std::ostream& out, const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10)
{
    fmt = detail::printFormatStringLiteral(out, fmt);
    const char* fmtEnd = detail::findFormatSpecEnd(fmt);
    formatValueBasic(out, fmt, fmtEnd, v1);
    format(out, fmtEnd, v2, v3, v4, v5, v6, v7, v8, v9, v10);
}
template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
inline std::string format(const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10)
{
    std::ostringstream oss;
    format(oss, fmt, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10);
    return oss.str();
}
template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
inline void printf(const char* fmt, const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10)
{
    format(std::cout, fmt, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10);
}
//[[[end]]]

// Special cases not covered by codegen above.
inline std::string format(const char* fmt)
{
    std::ostringstream oss;
    format(oss, fmt);
    return oss.str();
}
inline void printf(const char* fmt)
{
    format(std::cout, fmt);
}

#endif

} // namespace tinyformat

#endif // TINYFORMAT_H_INCLUDED
